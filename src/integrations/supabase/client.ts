// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';

// Get environment variables
const getSupabaseUrl = () => {
  const envUrl = import.meta.env.VITE_SUPABASE_URL;
  if (!envUrl) {
    throw new Error('VITE_SUPABASE_URL environment variable is required');
  }
  return envUrl;
};

const getSupabaseKey = () => {
  const envKey = import.meta.env.VITE_SUPABASE_ANON_KEY;
  if (!envKey) {
    throw new Error('VITE_SUPABASE_ANON_KEY environment variable is required');
  }
  return envKey;
};

const supabaseUrl = getSupabaseUrl();
const supabaseAnonKey = getSupabaseKey();

// Create Supabase client
export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    persistSession: true,
    storageKey: 'event-brite-maker-auth',
    storage: typeof window !== 'undefined' ? window.localStorage : null,
    autoRefreshToken: true,
    detectSessionInUrl: true,
    flowType: 'pkce'
  },
  db: {
    schema: 'public'
  }
  // REMOVED global headers to allow proper Content-Type for file uploads
  // Content-Type should be set per-request, not globally
});

// Function to delete QR code files from storage
export async function deleteQRCodeFiles(registrationId: string) {
  try {
    // Get all tickets for this registration to find QR code files
    const { data: tickets, error: ticketsError } = await supabase
      .from('tickets')
      .select('id, short_code')
      .eq('registration_id', registrationId);

    if (ticketsError) {
      console.error('Error fetching tickets for QR deletion:', ticketsError);
      return { success: false, error: ticketsError };
    }

    if (!tickets || tickets.length === 0) {
      console.log('No tickets found for registration:', registrationId);
      return { success: true, deletedFiles: [] };
    }

    // Delete QR code files from storage
    const deletedFiles = [];
    for (const ticket of tickets) {
      try {
        // Try to delete QR code file using short_code if available, otherwise use ticket ID
        const fileName = ticket.short_code ? `qr-${ticket.short_code}` : `qr-${ticket.id}`;
        const filePath = `qr-codes/${fileName}.png`;
        
        console.log('Attempting to delete QR file:', filePath);
        
        const { error: deleteError } = await supabase.storage
          .from('event-logos')
          .remove([filePath]);

        if (deleteError) {
          console.warn('Failed to delete QR file:', filePath, deleteError);
          // Continue with other files even if one fails
        } else {
          console.log('Successfully deleted QR file:', filePath);
          deletedFiles.push(filePath);
        }
      } catch (fileError) {
        console.warn('Error deleting QR file for ticket:', ticket.id, fileError);
        // Continue with other files
      }
    }

    return { success: true, deletedFiles };
  } catch (error) {
    console.error('Error in deleteQRCodeFiles:', error);
    return { success: false, error };
  }
}

// Function to delete registration by ID with complete cleanup
export async function deleteRegistration(id: string) {
  try {
    console.log('Starting deletion process for registration:', id);
    
    // First, delete QR code files from storage
    console.log('Deleting QR code files...');
    const qrDeleteResult = await deleteQRCodeFiles(id);
    if (qrDeleteResult.success) {
      console.log('QR files deleted:', qrDeleteResult.deletedFiles);
    } else {
      console.warn('Failed to delete some QR files:', qrDeleteResult.error);
    }

    // Then, delete all related tickets
    console.log('Deleting related tickets...');
    const { error: ticketsError } = await supabase
      .from('tickets')
      .delete()
      .eq('registration_id', id);

    if (ticketsError) {
      console.error('Error deleting related tickets:', ticketsError);
      throw ticketsError;
    }

    // Finally, delete the registration
    console.log('Deleting registration...');
    const { data, error } = await supabase
      .from('registrations')
      .delete()
      .eq('id', id)
      .select();

    if (error) {
      console.error('Error deleting registration:', error);
      throw error;
    }

    console.log('Registration deletion completed successfully');
    return { data, error: null };
  } catch (error) {
    console.error('Error in deleteRegistration:', error);
    return { data: null, error };
  }
}

// Function to test Supabase connection with environment variables
export async function testSupabaseConnectionWithEnv() {
  const envUrl = import.meta.env.VITE_SUPABASE_URL;
  const envKey = import.meta.env.VITE_SUPABASE_ANON_KEY;
  
  if (!envUrl || !envKey) {
    return { 
      success: false, 
      error: 'Environment variables not configured',
      missing: {
        url: !envUrl,
        key: !envKey
      }
    };
  }
  
  try {
    console.log(`Testing URL: ${envUrl}`);
    const testClient = createClient(envUrl, envKey, {
      auth: { autoRefreshToken: false }
    });
    
    const { data, error } = await testClient.auth.getSession();
    
    if (!error) {
      console.log(`Successfully connected to: ${envUrl}`);
      return { success: true, url: envUrl, data };
    } else {
      return { success: false, error: error.message };
    }
  } catch (error) {
    console.log(`Failed to connect to: ${envUrl}`, error);
    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
  }
}

// Function to test Supabase connection
export async function testSupabaseConnection() {
  console.log('Testing Supabase connection...');
  console.log('URL:', supabaseUrl);
  console.log('Key configured:', !!supabaseAnonKey);
  
  try {
    // Test basic connection with timeout
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Connection timeout')), 10000);
    });
    
    const connectionPromise = supabase.auth.getSession();
    
    const { data, error } = await Promise.race([connectionPromise, timeoutPromise]) as { data: unknown; error: unknown };
    
    if (error) {
      console.error('Primary connection test failed:', error);
      
      // Try environment variables as fallback
      console.log('Trying environment variables as fallback...');
      const envResult = await testSupabaseConnectionWithEnv();
      
      if (envResult.success) {
        console.log('Environment variables connection successful');
        return { success: true, data: envResult.data, usedFallback: true };
      }
      
      return { 
        success: false, 
        error: error instanceof Error ? error.message : 'Connection failed',
        details: error 
      };
    }
    
    console.log('Connection test successful');
    return { success: true, data };
  } catch (error) {
    console.error('Connection test error:', error);
    
    // Try environment variables as fallback
    console.log('Trying environment variables as fallback...');
    const envResult = await testSupabaseConnectionWithEnv();
    
    if (envResult.success) {
      console.log('Environment variables connection successful');
      return { success: true, data: envResult.data, usedFallback: true };
    }
    
    return { 
      success: false, 
      error: error instanceof Error ? error.message : 'Unknown connection error',
      details: error 
    };
  }
}

// Function to test connection and fetch events data
export async function testConnectionAndEvents() {
  console.log('Testing Supabase connection...');
  console.log('URL:', supabaseUrl);
  console.log('Key configured:', !!supabaseAnonKey);
  
  try {
    // Test basic connection
    const { data: eventsData, error: eventsError } = await supabase
      .from('events')
      .select('*')
      .limit(5);
    
    if (eventsError) {
      console.error('Events fetch error:', eventsError);
      return { success: false, error: eventsError };
    }
    
    console.log('Events data:', eventsData);
    
    // Test registrations with events join
    const { data: registrationsData, error: registrationsError } = await supabase
      .from('registrations')
      .select(`
        id,
        participant_name,
        participant_email,
        event_id,
        events (
          id,
          name
        )
      `)
      .limit(5);
    
    if (registrationsError) {
      console.error('Registrations fetch error:', registrationsError);
      return { success: false, error: registrationsError };
    }
    
    console.log('Registrations with events data:', registrationsData);
    
    // Debug: Check specific registration and its event
    if (registrationsData && registrationsData.length > 0) {
      const firstReg = registrationsData[0];
      console.log('First registration event_id:', firstReg.event_id);
      console.log('First registration events data:', firstReg.events);
      
      // Try to fetch the specific event directly
      const { data: specificEvent, error: specificEventError } = await supabase
        .from('events')
        .select('id, name')
        .eq('id', firstReg.event_id)
        .single();
      
      console.log('Specific event fetch result:', { data: specificEvent, error: specificEventError });
    }
    
    return { 
      success: true, 
      events: eventsData, 
      registrations: registrationsData 
    };
  } catch (error) {
    console.error('Connection test error:', error);
    return { success: false, error };
  }
}

// Function to test auth session and profile
export async function testAuthSession() {
  console.log('Testing auth session...');
  
  try {
    // Get current session
    const { data: { session }, error: sessionError } = await supabase.auth.getSession();
    
    if (sessionError) {
      console.error('Session error:', sessionError);
      return { success: false, error: sessionError };
    }
    
    console.log('Current session:', session);
    
    if (session?.user) {
      console.log('User found:', session.user.id);
      
      // Test profile fetch
      const { data: profile, error: profileError } = await supabase
        .from('profiles')
        .select('*')
        .eq('user_id', session.user.id)
        .single();
      
      if (profileError) {
        console.error('Profile fetch error:', profileError);
        return { success: false, error: profileError, session };
      }
      
      console.log('Profile found:', profile);
      return { success: true, session, profile };
    } else {
      console.log('No session found');
      return { success: false, session: null, profile: null };
    }
  } catch (error) {
    console.error('Auth session test error:', error);
    return { success: false, error };
  }
}

// Function to force refresh profile
export async function forceRefreshProfile(userId: string) {
  console.log('Force refreshing profile for user:', userId);
  
  try {
    const { data: profile, error } = await supabase
      .from('profiles')
      .select('*')
      .eq('user_id', userId)
      .single();
    
    if (error) {
      console.error('Force refresh profile error:', error);
      return { success: false, error };
    }
    
    console.log('Force refresh profile success:', profile);
    return { success: true, profile };
  } catch (error) {
    console.error('Force refresh profile error:', error);
    return { success: false, error };
  }
}